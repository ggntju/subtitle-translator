WEBVTT

1
00:00:00.000 --> 00:00:03.030
In this section, we'll
discuss Kotlin types,

2
00:00:03.030 --> 00:00:05.520
several Java types
they correspond to,

3
00:00:05.520 --> 00:00:06.840
and discuss what happens with

4
00:00:06.840 --> 00:00:09.330
these types under the hood
at the bytecode level.

5
00:00:09.330 --> 00:00:11.265
In Kotlin, we don't

6
00:00:11.265 --> 00:00:13.965
distinguish primitive
types and reference types.

7
00:00:13.965 --> 00:00:16.725
You either use Int
or nullable Int.

8
00:00:16.725 --> 00:00:18.975
There are no primitives
in the language.

9
00:00:18.975 --> 00:00:21.075
However, let's
discuss what happens

10
00:00:21.075 --> 00:00:23.640
under the hood at
the bytecode level.

11
00:00:23.640 --> 00:00:25.320
You can call show

12
00:00:25.320 --> 00:00:26.810
Kotlin bytecode action in

13
00:00:26.810 --> 00:00:28.940
IntelliJ idea or Android Studio.

14
00:00:28.940 --> 00:00:31.055
It opens you the
generated bytecode

15
00:00:31.055 --> 00:00:33.575
corresponding to
the open Kotlin file.

16
00:00:33.575 --> 00:00:36.770
In the bytecode, you can
check the return type

17
00:00:36.770 --> 00:00:39.410
for functions whether it
returns a primitive file,

18
00:00:39.410 --> 00:00:41.110
or your oil wrapper type.

19
00:00:41.110 --> 00:00:43.175
However, there is
an easier option.

20
00:00:43.175 --> 00:00:45.275
You see here
the decompile button.

21
00:00:45.275 --> 00:00:46.670
This button will decompile

22
00:00:46.670 --> 00:00:49.040
the generated bytecode to
the analogous Java code.

23
00:00:49.040 --> 00:00:50.630
If you click on it, you'll see

24
00:00:50.630 --> 00:00:52.010
the Java code that corresponds

25
00:00:52.010 --> 00:00:53.375
to the initial Kotlin code.

26
00:00:53.375 --> 00:00:55.070
That's a good illustration of how

27
00:00:55.070 --> 00:00:56.090
the Kotlin functions and

28
00:00:56.090 --> 00:00:57.830
classes are implemented
under the hood.

29
00:00:57.830 --> 00:00:59.420
At the same time, it shows

30
00:00:59.420 --> 00:01:01.310
how Java sees
Kotlin functions and

31
00:01:01.310 --> 00:01:03.080
classes because Java just

32
00:01:03.080 --> 00:01:06.630
accesses the Kotlin code
via generated bytecode.

33
00:01:07.370 --> 00:01:10.130
As you can see, when you use

34
00:01:10.130 --> 00:01:12.080
a regular Int type in Kotlin,

35
00:01:12.080 --> 00:01:15.200
it corresponds to a primitive
Int type under the hood.

36
00:01:15.200 --> 00:01:17.105
When you use nullable Int,

37
00:01:17.105 --> 00:01:18.920
this value can straw nulls.

38
00:01:18.920 --> 00:01:21.685
So, it should correspond
to a wrapper type in Java.

39
00:01:21.685 --> 00:01:24.380
We don't have primitive
types in the language,

40
00:01:24.380 --> 00:01:27.095
but we still have them
at the bytecode level.

41
00:01:27.095 --> 00:01:28.955
The same applies to

42
00:01:28.955 --> 00:01:32.555
other primitives like
double float or Boolean.

43
00:01:32.555 --> 00:01:36.845
Note however that if you use
Int as a generic argument,

44
00:01:36.845 --> 00:01:39.410
then it can't be
compiled to a primitive

45
00:01:39.410 --> 00:01:42.425
because you cannot use
primitives as generic arguments.

46
00:01:42.425 --> 00:01:45.040
It becomes a reference type.

47
00:01:45.040 --> 00:01:47.730
The same works for arrays.

48
00:01:47.730 --> 00:01:50.810
When you use Int as
a generic argument of array,

49
00:01:50.810 --> 00:01:53.780
that corresponds to an array
of [inaudible] types.

50
00:01:53.780 --> 00:01:57.020
To get an array of primitive
types under the hood,

51
00:01:57.020 --> 00:01:58.460
you need to use an extra class

52
00:01:58.460 --> 00:02:01.260
like Int array or double array.

53
00:02:01.480 --> 00:02:04.399
Kotlin string is replaced

54
00:02:04.399 --> 00:02:06.685
with Java lang string
at the bytecode.

55
00:02:06.685 --> 00:02:09.290
Kotlin doesn't have
its own string implementation.

56
00:02:09.290 --> 00:02:12.485
However, it modifies
the bit of the string API.

57
00:02:12.485 --> 00:02:15.005
For instance, Kotlin string has

58
00:02:15.005 --> 00:02:16.400
some confusing methods that are

59
00:02:16.400 --> 00:02:18.175
present in Java lang string.

60
00:02:18.175 --> 00:02:21.035
In Java, you can use
the replace all method.

61
00:02:21.035 --> 00:02:23.420
Surprisingly, it will
return your all stars

62
00:02:23.420 --> 00:02:25.960
so when you try to replace
only a dot with this star.

63
00:02:25.960 --> 00:02:28.880
That happens because dot here
is a regular expression.

64
00:02:28.880 --> 00:02:31.205
In Kotlin, we have
two separate methods.

65
00:02:31.205 --> 00:02:32.990
The first one replaces dot with

66
00:02:32.990 --> 00:02:35.390
stars and works as you expect.

67
00:02:35.390 --> 00:02:37.565
It simply replaces sub-strings.

68
00:02:37.565 --> 00:02:39.590
If you want regular expressions,

69
00:02:39.590 --> 00:02:42.505
you pass a specific regular
expression type not a string.

70
00:02:42.505 --> 00:02:46.235
Now you're not surprised
seeing the result.

71
00:02:46.235 --> 00:02:48.690
Any is replaced with

72
00:02:48.690 --> 00:02:50.895
Java lang object added
to the bytecode.

73
00:02:50.895 --> 00:02:54.540
Any in Kotlin is a super type
for all non-nullable types.

74
00:02:54.540 --> 00:02:56.610
Unlike object, any is

75
00:02:56.610 --> 00:02:59.415
not only super type
for reference types,

76
00:02:59.415 --> 00:03:01.710
but it's also
super type for types

77
00:03:01.710 --> 00:03:04.340
like Int corresponding
to primitives.

78
00:03:04.340 --> 00:03:06.560
Note that under the hood,

79
00:03:06.560 --> 00:03:09.155
the autoboxing still
happens like in Java.

80
00:03:09.155 --> 00:03:10.910
When you pass an integer as

81
00:03:10.910 --> 00:03:13.285
an argument to a function
that expects any,

82
00:03:13.285 --> 00:03:16.565
this integer will be autoboxed
to a reference type.

83
00:03:16.565 --> 00:03:18.770
The same happens in
Java when you pass a

84
00:03:18.770 --> 00:03:21.695
primitive as
an instance of object.

85
00:03:21.695 --> 00:03:23.840
If you want to avoid it,

86
00:03:23.840 --> 00:03:26.290
you declare a function
that takes Int.

87
00:03:26.290 --> 00:03:27.620
Now, it corresponds to

88
00:03:27.620 --> 00:03:29.180
a function that takes
a primitive int

89
00:03:29.180 --> 00:03:32.180
and the primitive value
can be just passed to it.

90
00:03:32.180 --> 00:03:34.970
No boxing happens in this case.

91
00:03:34.970 --> 00:03:38.960
Add to the bytecode unless
lambdas are in lined,

92
00:03:38.960 --> 00:03:41.330
the Kotlin function types
are replaced with

93
00:03:41.330 --> 00:03:43.700
regular interfaces
like function zero,

94
00:03:43.700 --> 00:03:45.170
function one and function two

95
00:03:45.170 --> 00:03:47.705
with the corresponding
generic arguments.

96
00:03:47.705 --> 00:03:49.910
You can find the declaration of

97
00:03:49.910 --> 00:03:52.400
this function interfaces
in the library.

98
00:03:52.400 --> 00:03:54.095
In the Kotlin code,

99
00:03:54.095 --> 00:03:56.300
you use the concise
syntactic forms for

100
00:03:56.300 --> 00:03:58.190
function types which are replaced

101
00:03:58.190 --> 00:04:00.350
by the corresponding
interfaces under the hood.

102
00:04:00.350 --> 00:04:02.500
When the lambda is not in lined,

103
00:04:02.500 --> 00:04:03.980
an instance of the corresponding

104
00:04:03.980 --> 00:04:05.870
function interface is passed.

105
00:04:05.870 --> 00:04:08.060
If the lambda is in lined, then

106
00:04:08.060 --> 00:04:11.315
[inaudible] is created all the
code is generated directly.

107
00:04:11.315 --> 00:04:14.180
When you call a variable
of a function type as

108
00:04:14.180 --> 00:04:17.050
a function using the parentheses
in the bytecode,

109
00:04:17.050 --> 00:04:20.360
this call is replaced with
a direct invoke call.

110
00:04:20.360 --> 00:04:22.925
Unless this code is
in light of course.

111
00:04:22.925 --> 00:04:25.325
As we've already discussed,

112
00:04:25.325 --> 00:04:27.960
you can call invoke
explicitly from Kotlin.

113
00:04:27.960 --> 00:04:29.665
For expressions of
function types,

114
00:04:29.665 --> 00:04:32.120
is the same as using
the concise syntax.

115
00:04:32.120 --> 00:04:35.030
The case when it's really
helpful is working

116
00:04:35.030 --> 00:04:38.405
with variables of
nullable function types.

117
00:04:38.405 --> 00:04:42.740
The next question returns us
to the discussion of arrays.

118
00:04:42.740 --> 00:04:45.980
What will be printed
here? True or false?

119
00:04:45.980 --> 00:04:49.505
Under the hood, Kotlin arrays
are regular Java arrays.

120
00:04:49.505 --> 00:04:50.900
Specifically, they don't

121
00:04:50.900 --> 00:04:52.850
override the equals
implementation.

122
00:04:52.850 --> 00:04:55.010
Equals for Kotlin arrays works

123
00:04:55.010 --> 00:04:58.320
in the same way as
for Java arrays.

124
00:04:58.320 --> 00:05:01.295
The right answer is false.

125
00:05:01.295 --> 00:05:03.575
I have told you
that Kotlin arrays

126
00:05:03.575 --> 00:05:05.770
simply corresponds
to Java arrays.

127
00:05:05.770 --> 00:05:09.320
In Java, you have to be
aware that by default,

128
00:05:09.320 --> 00:05:12.025
equals checks reference
equality for arrays.

129
00:05:12.025 --> 00:05:13.850
If you need to check the contents

130
00:05:13.850 --> 00:05:15.290
instead of reference equality,

131
00:05:15.290 --> 00:05:17.080
can use arrays equals.

132
00:05:17.080 --> 00:05:20.040
In Kotlin, it works
in a similar manner.

133
00:05:20.040 --> 00:05:21.750
Double equals sign which

134
00:05:21.750 --> 00:05:23.840
calls equals in
Kotlin only checks

135
00:05:23.840 --> 00:05:25.910
reference equality
since equals method

136
00:05:25.910 --> 00:05:27.800
for arrays works that way.

137
00:05:27.800 --> 00:05:29.885
In Kotlin, you use the extension

138
00:05:29.885 --> 00:05:32.960
content equals to
compare the contents.

139
00:05:32.960 --> 00:05:36.685
The good news is that in
Kotlin you rarely use arrays.

140
00:05:36.685 --> 00:05:38.390
Kotlin has arrays specifically

141
00:05:38.390 --> 00:05:40.085
to have good Java
interoperability

142
00:05:40.085 --> 00:05:43.850
to make it easier to work with
Java API that uses arrays.

143
00:05:43.850 --> 00:05:45.920
If you write the Kotlin
application from

144
00:05:45.920 --> 00:05:47.810
scratch and use only Kotlin,

145
00:05:47.810 --> 00:05:49.460
there is no reason for arrays.

146
00:05:49.460 --> 00:05:51.025
You can simply use lists.

147
00:05:51.025 --> 00:05:52.780
As we'll discuss later,

148
00:05:52.780 --> 00:05:56.450
mutable list is Java util
array list under the hood.

149
00:05:56.450 --> 00:05:58.070
Array list is very close

150
00:05:58.070 --> 00:05:59.540
to array in terms of performance.

151
00:05:59.540 --> 00:06:02.510
So, prefer lists to
arrays by default and

152
00:06:02.510 --> 00:06:04.040
avoid the necessity to remember

153
00:06:04.040 --> 00:06:05.845
the right way to compare arrays.

154
00:06:05.845 --> 00:06:08.570
You now know that
despite Kotlin doesn't

155
00:06:08.570 --> 00:06:11.660
distinguish between
primitive and reference types,

156
00:06:11.660 --> 00:06:13.985
they're still hidden
under the hood.

157
00:06:13.985 --> 00:06:16.320
The boxing happens
whenever you interpret

158
00:06:16.320 --> 00:06:19.465
a primitive value as
a value of reference type.

159
00:06:19.465 --> 00:06:22.700
Next, we'll uncover the
difference between nothing and

160
00:06:22.700 --> 00:06:26.730
unit types and compare
them with Javas void.